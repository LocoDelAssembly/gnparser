// Code generated by protoc-gen-go. DO NOT EDIT.
// source: gnparser.proto

// Version contains version of gnparser as well as the timestamp when it
// was compiled.

package pb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NameType int32

const (
	// NONE is for unparsed names.
	NameType_NONE NameType = 0
	// UNINOMIAL is for names of genus and higher taxa.
	NameType_UNINOMIAL NameType = 1
	// SPECIES is for species and lower taxa (subspecies, varieties etc).
	NameType_SPECIES NameType = 2
	// COMPARISON is for names with uncertain identification.
	NameType_COMPARISON NameType = 3
	// APPROX_SURROGATE is for suroogate names with incomplete identification.
	NameType_APPROX_SURROGATE NameType = 4
	// SURROGATE is for all other surrogate names.
	NameType_SURROGATE NameType = 5
	// NAMED_HYBRID is for names that designate stable hybrids that are given
	// their own name.
	NameType_NAMED_HYBRID NameType = 6
	// HYBRID_FORMULA is for names built from several 'simple' names.
	NameType_HYBRID_FORMULA NameType = 7
	// VIRUS is for names of viruses, plasmids etc.
	NameType_VIRUS NameType = 8
)

var NameType_name = map[int32]string{
	0: "NONE",
	1: "UNINOMIAL",
	2: "SPECIES",
	3: "COMPARISON",
	4: "APPROX_SURROGATE",
	5: "SURROGATE",
	6: "NAMED_HYBRID",
	7: "HYBRID_FORMULA",
	8: "VIRUS",
}

var NameType_value = map[string]int32{
	"NONE":             0,
	"UNINOMIAL":        1,
	"SPECIES":          2,
	"COMPARISON":       3,
	"APPROX_SURROGATE": 4,
	"SURROGATE":        5,
	"NAMED_HYBRID":     6,
	"HYBRID_FORMULA":   7,
	"VIRUS":            8,
}

func (x NameType) String() string {
	return proto.EnumName(NameType_name, int32(x))
}

func (NameType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{0}
}

type Version struct {
	Value                string   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	BuildTime            string   `protobuf:"bytes,2,opt,name=build_time,json=buildTime,proto3" json:"build_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{0}
}

func (m *Version) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Version.Unmarshal(m, b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Version.Marshal(b, m, deterministic)
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return xxx_messageInfo_Version.Size(m)
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Version) GetBuildTime() string {
	if m != nil {
		return m.BuildTime
	}
	return ""
}

// Void is an empty input.
type Void struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{1}
}

func (m *Void) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Void.Unmarshal(m, b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Void.Marshal(b, m, deterministic)
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return xxx_messageInfo_Void.Size(m)
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

// InputArray contains name-strings to parse as well as options for parsing.
type InputArray struct {
	// jobs_number sets how many go-routines will be created. If this number is
	// higher than max number of jobs set by gnparser's gRPC server, it will be
	// ignored and max number of jobs will be used instead.
	JobsNumber int32 `protobuf:"varint,1,opt,name=jobs_number,json=jobsNumber,proto3" json:"jobs_number,omitempty"`
	// skip_cleaning indicates weather to run removal of HTML tags or not. When
	// it is true HTML tags are not remooved and names that contain them will not
	// be parsed.
	SkipCleaning bool `protobuf:"varint,2,opt,name=skip_cleaning,json=skipCleaning,proto3" json:"skip_cleaning,omitempty"`
	// names is a list of name-strings to parse.
	Names                []string `protobuf:"bytes,3,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InputArray) Reset()         { *m = InputArray{} }
func (m *InputArray) String() string { return proto.CompactTextString(m) }
func (*InputArray) ProtoMessage()    {}
func (*InputArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{2}
}

func (m *InputArray) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InputArray.Unmarshal(m, b)
}
func (m *InputArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InputArray.Marshal(b, m, deterministic)
}
func (m *InputArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputArray.Merge(m, src)
}
func (m *InputArray) XXX_Size() int {
	return xxx_messageInfo_InputArray.Size(m)
}
func (m *InputArray) XXX_DiscardUnknown() {
	xxx_messageInfo_InputArray.DiscardUnknown(m)
}

var xxx_messageInfo_InputArray proto.InternalMessageInfo

func (m *InputArray) GetJobsNumber() int32 {
	if m != nil {
		return m.JobsNumber
	}
	return 0
}

func (m *InputArray) GetSkipCleaning() bool {
	if m != nil {
		return m.SkipCleaning
	}
	return false
}

func (m *InputArray) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type OutputArray struct {
	// output contains results of parsing. It keeps the same order of output as
	// the one given in the input.
	Output               []*Parsed `protobuf:"bytes,1,rep,name=output,proto3" json:"output,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *OutputArray) Reset()         { *m = OutputArray{} }
func (m *OutputArray) String() string { return proto.CompactTextString(m) }
func (*OutputArray) ProtoMessage()    {}
func (*OutputArray) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{3}
}

func (m *OutputArray) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OutputArray.Unmarshal(m, b)
}
func (m *OutputArray) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OutputArray.Marshal(b, m, deterministic)
}
func (m *OutputArray) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OutputArray.Merge(m, src)
}
func (m *OutputArray) XXX_Size() int {
	return xxx_messageInfo_OutputArray.Size(m)
}
func (m *OutputArray) XXX_DiscardUnknown() {
	xxx_messageInfo_OutputArray.DiscardUnknown(m)
}

var xxx_messageInfo_OutputArray proto.InternalMessageInfo

func (m *OutputArray) GetOutput() []*Parsed {
	if m != nil {
		return m.Output
	}
	return nil
}

type Parsed struct {
	// parsed is false if parsing a string failed.
	Parsed bool `protobuf:"varint,1,opt,name=parsed,proto3" json:"parsed,omitempty"`
	// quality is 1 when name parsed well, 2 if there were some inconsistencies,
	// and 3 when name contains serious problems.
	Quality int32 `protobuf:"varint,2,opt,name=quality,proto3" json:"quality,omitempty"`
	// quality_warning is empty if quality is 1. In other cases it contains a
	// a list of parsing problems.
	QualityWarning []*QualityWarning `protobuf:"bytes,3,rep,name=quality_warning,json=qualityWarning,proto3" json:"quality_warning,omitempty"`
	// verbatim as the original name-string as it was given with input.
	Verbatim string `protobuf:"bytes,4,opt,name=verbatim,proto3" json:"verbatim,omitempty"`
	// normalized is cleaned-up version of the input name-string
	Normalized string `protobuf:"bytes,5,opt,name=normalized,proto3" json:"normalized,omitempty"`
	// canoincal contains the "core" of scientific name without authorships.
	Canonical *Canonical `protobuf:"bytes,6,opt,name=canonical,proto3" json:"canonical,omitempty"`
	// authorship of the name. It is nil when authorship of the most specific
	// element of the name is not given.
	Authorship *Authorship `protobuf:"bytes,7,opt,name=authorship,proto3" json:"authorship,omitempty"`
	// flattened list of words in the name, their offsets and the semantic
	// meaning.
	Positions []*Position `protobuf:"bytes,8,rep,name=positions,proto3" json:"positions,omitempty"`
	// hybrid is true for named hybrids and hybrid formulas.
	Hybrid bool `protobuf:"varint,9,opt,name=hybrid,proto3" json:"hybrid,omitempty"`
	// is true if a name contains an unambiguous bacterial genus.
	Bacteria bool `protobuf:"varint,10,opt,name=bacteria,proto3" json:"bacteria,omitempty"`
	// tail contains unparseable end of a string, if it exists.
	Tail string `protobuf:"bytes,11,opt,name=tail,proto3" json:"tail,omitempty"`
	// id is a UUID version 5. It is always the same for a particular name-string.
	Id string `protobuf:"bytes,12,opt,name=id,proto3" json:"id,omitempty"`
	// parser_version is the version of gnparser.
	ParserVersion string `protobuf:"bytes,13,opt,name=parser_version,json=parserVersion,proto3" json:"parser_version,omitempty"`
	// cardinality is the number of main elements of a name. For uninomials it is
	// 1, for binomials 2, for trinomials 3 etc. For viruses, hybrid formulas we
	// return 0.
	Cardinality int32 `protobuf:"varint,14,opt,name=cardinality,proto3" json:"cardinality,omitempty"`
	// name_type designates the kind of a name.
	NameType NameType `protobuf:"varint,15,opt,name=name_type,json=nameType,proto3,enum=pb.NameType" json:"name_type,omitempty"`
	// details break name into smallest semantic elements.
	//
	// Types that are valid to be assigned to Details:
	//	*Parsed_Uninomial
	//	*Parsed_Species
	//	*Parsed_Comparison
	//	*Parsed_Approximation
	Details isParsed_Details `protobuf_oneof:"details"`
	// detailes_hybrid_formula describes details of hybrids. Hybrid formula
	// contains several names.
	DetailsHybridFormula []*HybridFormula `protobuf:"bytes,20,rep,name=details_hybrid_formula,json=detailsHybridFormula,proto3" json:"details_hybrid_formula,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Parsed) Reset()         { *m = Parsed{} }
func (m *Parsed) String() string { return proto.CompactTextString(m) }
func (*Parsed) ProtoMessage()    {}
func (*Parsed) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{4}
}

func (m *Parsed) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Parsed.Unmarshal(m, b)
}
func (m *Parsed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Parsed.Marshal(b, m, deterministic)
}
func (m *Parsed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Parsed.Merge(m, src)
}
func (m *Parsed) XXX_Size() int {
	return xxx_messageInfo_Parsed.Size(m)
}
func (m *Parsed) XXX_DiscardUnknown() {
	xxx_messageInfo_Parsed.DiscardUnknown(m)
}

var xxx_messageInfo_Parsed proto.InternalMessageInfo

func (m *Parsed) GetParsed() bool {
	if m != nil {
		return m.Parsed
	}
	return false
}

func (m *Parsed) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *Parsed) GetQualityWarning() []*QualityWarning {
	if m != nil {
		return m.QualityWarning
	}
	return nil
}

func (m *Parsed) GetVerbatim() string {
	if m != nil {
		return m.Verbatim
	}
	return ""
}

func (m *Parsed) GetNormalized() string {
	if m != nil {
		return m.Normalized
	}
	return ""
}

func (m *Parsed) GetCanonical() *Canonical {
	if m != nil {
		return m.Canonical
	}
	return nil
}

func (m *Parsed) GetAuthorship() *Authorship {
	if m != nil {
		return m.Authorship
	}
	return nil
}

func (m *Parsed) GetPositions() []*Position {
	if m != nil {
		return m.Positions
	}
	return nil
}

func (m *Parsed) GetHybrid() bool {
	if m != nil {
		return m.Hybrid
	}
	return false
}

func (m *Parsed) GetBacteria() bool {
	if m != nil {
		return m.Bacteria
	}
	return false
}

func (m *Parsed) GetTail() string {
	if m != nil {
		return m.Tail
	}
	return ""
}

func (m *Parsed) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Parsed) GetParserVersion() string {
	if m != nil {
		return m.ParserVersion
	}
	return ""
}

func (m *Parsed) GetCardinality() int32 {
	if m != nil {
		return m.Cardinality
	}
	return 0
}

func (m *Parsed) GetNameType() NameType {
	if m != nil {
		return m.NameType
	}
	return NameType_NONE
}

type isParsed_Details interface {
	isParsed_Details()
}

type Parsed_Uninomial struct {
	Uninomial *Uninomial `protobuf:"bytes,16,opt,name=uninomial,proto3,oneof"`
}

type Parsed_Species struct {
	Species *Species `protobuf:"bytes,17,opt,name=species,proto3,oneof"`
}

type Parsed_Comparison struct {
	Comparison *Comparison `protobuf:"bytes,18,opt,name=comparison,proto3,oneof"`
}

type Parsed_Approximation struct {
	Approximation *Approximation `protobuf:"bytes,19,opt,name=approximation,proto3,oneof"`
}

func (*Parsed_Uninomial) isParsed_Details() {}

func (*Parsed_Species) isParsed_Details() {}

func (*Parsed_Comparison) isParsed_Details() {}

func (*Parsed_Approximation) isParsed_Details() {}

func (m *Parsed) GetDetails() isParsed_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *Parsed) GetUninomial() *Uninomial {
	if x, ok := m.GetDetails().(*Parsed_Uninomial); ok {
		return x.Uninomial
	}
	return nil
}

func (m *Parsed) GetSpecies() *Species {
	if x, ok := m.GetDetails().(*Parsed_Species); ok {
		return x.Species
	}
	return nil
}

func (m *Parsed) GetComparison() *Comparison {
	if x, ok := m.GetDetails().(*Parsed_Comparison); ok {
		return x.Comparison
	}
	return nil
}

func (m *Parsed) GetApproximation() *Approximation {
	if x, ok := m.GetDetails().(*Parsed_Approximation); ok {
		return x.Approximation
	}
	return nil
}

func (m *Parsed) GetDetailsHybridFormula() []*HybridFormula {
	if m != nil {
		return m.DetailsHybridFormula
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Parsed) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Parsed_Uninomial)(nil),
		(*Parsed_Species)(nil),
		(*Parsed_Comparison)(nil),
		(*Parsed_Approximation)(nil),
	}
}

type HybridFormula struct {
	// element describes one of names in the hybrid formula.
	//
	// Types that are valid to be assigned to Element:
	//	*HybridFormula_Uninomial
	//	*HybridFormula_Species
	//	*HybridFormula_Comparison
	//	*HybridFormula_Approximation
	Element              isHybridFormula_Element `protobuf_oneof:"element"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HybridFormula) Reset()         { *m = HybridFormula{} }
func (m *HybridFormula) String() string { return proto.CompactTextString(m) }
func (*HybridFormula) ProtoMessage()    {}
func (*HybridFormula) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{5}
}

func (m *HybridFormula) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HybridFormula.Unmarshal(m, b)
}
func (m *HybridFormula) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HybridFormula.Marshal(b, m, deterministic)
}
func (m *HybridFormula) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HybridFormula.Merge(m, src)
}
func (m *HybridFormula) XXX_Size() int {
	return xxx_messageInfo_HybridFormula.Size(m)
}
func (m *HybridFormula) XXX_DiscardUnknown() {
	xxx_messageInfo_HybridFormula.DiscardUnknown(m)
}

var xxx_messageInfo_HybridFormula proto.InternalMessageInfo

type isHybridFormula_Element interface {
	isHybridFormula_Element()
}

type HybridFormula_Uninomial struct {
	Uninomial *Uninomial `protobuf:"bytes,1,opt,name=uninomial,proto3,oneof"`
}

type HybridFormula_Species struct {
	Species *Species `protobuf:"bytes,2,opt,name=species,proto3,oneof"`
}

type HybridFormula_Comparison struct {
	Comparison *Comparison `protobuf:"bytes,3,opt,name=comparison,proto3,oneof"`
}

type HybridFormula_Approximation struct {
	Approximation *Approximation `protobuf:"bytes,4,opt,name=approximation,proto3,oneof"`
}

func (*HybridFormula_Uninomial) isHybridFormula_Element() {}

func (*HybridFormula_Species) isHybridFormula_Element() {}

func (*HybridFormula_Comparison) isHybridFormula_Element() {}

func (*HybridFormula_Approximation) isHybridFormula_Element() {}

func (m *HybridFormula) GetElement() isHybridFormula_Element {
	if m != nil {
		return m.Element
	}
	return nil
}

func (m *HybridFormula) GetUninomial() *Uninomial {
	if x, ok := m.GetElement().(*HybridFormula_Uninomial); ok {
		return x.Uninomial
	}
	return nil
}

func (m *HybridFormula) GetSpecies() *Species {
	if x, ok := m.GetElement().(*HybridFormula_Species); ok {
		return x.Species
	}
	return nil
}

func (m *HybridFormula) GetComparison() *Comparison {
	if x, ok := m.GetElement().(*HybridFormula_Comparison); ok {
		return x.Comparison
	}
	return nil
}

func (m *HybridFormula) GetApproximation() *Approximation {
	if x, ok := m.GetElement().(*HybridFormula_Approximation); ok {
		return x.Approximation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*HybridFormula) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*HybridFormula_Uninomial)(nil),
		(*HybridFormula_Species)(nil),
		(*HybridFormula_Comparison)(nil),
		(*HybridFormula_Approximation)(nil),
	}
}

type Canonical struct {
	// stem contains simple canonical form with
	// removed suffixes for species, infraspecies.
	Stem string `protobuf:"bytes,1,opt,name=stem,proto3" json:"stem,omitempty"`
	// simple contains canonical form without ranks.
	Simple string `protobuf:"bytes,2,opt,name=simple,proto3" json:"simple,omitempty"`
	// full contains canonical form with ranks.
	Full                 string   `protobuf:"bytes,3,opt,name=full,proto3" json:"full,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Canonical) Reset()         { *m = Canonical{} }
func (m *Canonical) String() string { return proto.CompactTextString(m) }
func (*Canonical) ProtoMessage()    {}
func (*Canonical) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{6}
}

func (m *Canonical) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Canonical.Unmarshal(m, b)
}
func (m *Canonical) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Canonical.Marshal(b, m, deterministic)
}
func (m *Canonical) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Canonical.Merge(m, src)
}
func (m *Canonical) XXX_Size() int {
	return xxx_messageInfo_Canonical.Size(m)
}
func (m *Canonical) XXX_DiscardUnknown() {
	xxx_messageInfo_Canonical.DiscardUnknown(m)
}

var xxx_messageInfo_Canonical proto.InternalMessageInfo

func (m *Canonical) GetStem() string {
	if m != nil {
		return m.Stem
	}
	return ""
}

func (m *Canonical) GetSimple() string {
	if m != nil {
		return m.Simple
	}
	return ""
}

func (m *Canonical) GetFull() string {
	if m != nil {
		return m.Full
	}
	return ""
}

type Position struct {
	// type is a semantic meaning of a word.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// start is an offset of the start of the word.
	Start int32 `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	// end is an offset of the end of the word.
	End                  int32    `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{7}
}

func (m *Position) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Position.Unmarshal(m, b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Position.Marshal(b, m, deterministic)
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return xxx_messageInfo_Position.Size(m)
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Position) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Position) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

type QualityWarning struct {
	// quality of the warning. 2 means minor inconsistencies, 3 means
	// major problems.
	Quality int32 `protobuf:"varint,1,opt,name=quality,proto3" json:"quality,omitempty"`
	// message describes the warning.
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QualityWarning) Reset()         { *m = QualityWarning{} }
func (m *QualityWarning) String() string { return proto.CompactTextString(m) }
func (*QualityWarning) ProtoMessage()    {}
func (*QualityWarning) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{8}
}

func (m *QualityWarning) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QualityWarning.Unmarshal(m, b)
}
func (m *QualityWarning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QualityWarning.Marshal(b, m, deterministic)
}
func (m *QualityWarning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QualityWarning.Merge(m, src)
}
func (m *QualityWarning) XXX_Size() int {
	return xxx_messageInfo_QualityWarning.Size(m)
}
func (m *QualityWarning) XXX_DiscardUnknown() {
	xxx_messageInfo_QualityWarning.DiscardUnknown(m)
}

var xxx_messageInfo_QualityWarning proto.InternalMessageInfo

func (m *QualityWarning) GetQuality() int32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

func (m *QualityWarning) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Uninomial struct {
	// value of the uninomial, like 'Homo' for 'Homo L.'
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// rank of the uninomial, if given.
	Rank string `protobuf:"bytes,2,opt,name=rank,proto3" json:"rank,omitempty"`
	// higher clade of the uninomial, if given.
	Parent string `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	// authorship of the uninomial, if given.
	Authorship           *Authorship `protobuf:"bytes,4,opt,name=authorship,proto3" json:"authorship,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Uninomial) Reset()         { *m = Uninomial{} }
func (m *Uninomial) String() string { return proto.CompactTextString(m) }
func (*Uninomial) ProtoMessage()    {}
func (*Uninomial) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{9}
}

func (m *Uninomial) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Uninomial.Unmarshal(m, b)
}
func (m *Uninomial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Uninomial.Marshal(b, m, deterministic)
}
func (m *Uninomial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Uninomial.Merge(m, src)
}
func (m *Uninomial) XXX_Size() int {
	return xxx_messageInfo_Uninomial.Size(m)
}
func (m *Uninomial) XXX_DiscardUnknown() {
	xxx_messageInfo_Uninomial.DiscardUnknown(m)
}

var xxx_messageInfo_Uninomial proto.InternalMessageInfo

func (m *Uninomial) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Uninomial) GetRank() string {
	if m != nil {
		return m.Rank
	}
	return ""
}

func (m *Uninomial) GetParent() string {
	if m != nil {
		return m.Parent
	}
	return ""
}

func (m *Uninomial) GetAuthorship() *Authorship {
	if m != nil {
		return m.Authorship
	}
	return nil
}

type Species struct {
	// genux of the name.
	Genus string `protobuf:"bytes,1,opt,name=genus,proto3" json:"genus,omitempty"`
	// sub_genus of the name, if given.
	SubGenus string `protobuf:"bytes,2,opt,name=sub_genus,json=subGenus,proto3" json:"sub_genus,omitempty"`
	// species epithet of the name.
	Species string `protobuf:"bytes,3,opt,name=species,proto3" json:"species,omitempty"`
	// authorship of the specific epithet.
	SpeciesAuthorship *Authorship `protobuf:"bytes,4,opt,name=species_authorship,json=speciesAuthorship,proto3" json:"species_authorship,omitempty"`
	// details of subspecies, varieties etc, if given.
	InfraSpecies         []*InfraSpecies `protobuf:"bytes,5,rep,name=infra_species,json=infraSpecies,proto3" json:"infra_species,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Species) Reset()         { *m = Species{} }
func (m *Species) String() string { return proto.CompactTextString(m) }
func (*Species) ProtoMessage()    {}
func (*Species) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{10}
}

func (m *Species) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Species.Unmarshal(m, b)
}
func (m *Species) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Species.Marshal(b, m, deterministic)
}
func (m *Species) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Species.Merge(m, src)
}
func (m *Species) XXX_Size() int {
	return xxx_messageInfo_Species.Size(m)
}
func (m *Species) XXX_DiscardUnknown() {
	xxx_messageInfo_Species.DiscardUnknown(m)
}

var xxx_messageInfo_Species proto.InternalMessageInfo

func (m *Species) GetGenus() string {
	if m != nil {
		return m.Genus
	}
	return ""
}

func (m *Species) GetSubGenus() string {
	if m != nil {
		return m.SubGenus
	}
	return ""
}

func (m *Species) GetSpecies() string {
	if m != nil {
		return m.Species
	}
	return ""
}

func (m *Species) GetSpeciesAuthorship() *Authorship {
	if m != nil {
		return m.SpeciesAuthorship
	}
	return nil
}

func (m *Species) GetInfraSpecies() []*InfraSpecies {
	if m != nil {
		return m.InfraSpecies
	}
	return nil
}

type InfraSpecies struct {
	// value of the infraspecific epithet.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// rank of the inraspecific epithet.
	Rank string `protobuf:"bytes,2,opt,name=rank,proto3" json:"rank,omitempty"`
	// authorship of the infraspecific epithet.
	Authorship           *Authorship `protobuf:"bytes,3,opt,name=authorship,proto3" json:"authorship,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *InfraSpecies) Reset()         { *m = InfraSpecies{} }
func (m *InfraSpecies) String() string { return proto.CompactTextString(m) }
func (*InfraSpecies) ProtoMessage()    {}
func (*InfraSpecies) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{11}
}

func (m *InfraSpecies) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InfraSpecies.Unmarshal(m, b)
}
func (m *InfraSpecies) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InfraSpecies.Marshal(b, m, deterministic)
}
func (m *InfraSpecies) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InfraSpecies.Merge(m, src)
}
func (m *InfraSpecies) XXX_Size() int {
	return xxx_messageInfo_InfraSpecies.Size(m)
}
func (m *InfraSpecies) XXX_DiscardUnknown() {
	xxx_messageInfo_InfraSpecies.DiscardUnknown(m)
}

var xxx_messageInfo_InfraSpecies proto.InternalMessageInfo

func (m *InfraSpecies) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *InfraSpecies) GetRank() string {
	if m != nil {
		return m.Rank
	}
	return ""
}

func (m *InfraSpecies) GetAuthorship() *Authorship {
	if m != nil {
		return m.Authorship
	}
	return nil
}

type Comparison struct {
	// genus of the name.
	Genus string `protobuf:"bytes,1,opt,name=genus,proto3" json:"genus,omitempty"`
	// specific epithet of the name.
	Species string `protobuf:"bytes,2,opt,name=species,proto3" json:"species,omitempty"`
	// authorship of the name.
	SpeciesAuthorship *Authorship `protobuf:"bytes,3,opt,name=species_authorship,json=speciesAuthorship,proto3" json:"species_authorship,omitempty"`
	// comparison marker (usually cf.).
	Comparison           string   `protobuf:"bytes,4,opt,name=comparison,proto3" json:"comparison,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Comparison) Reset()         { *m = Comparison{} }
func (m *Comparison) String() string { return proto.CompactTextString(m) }
func (*Comparison) ProtoMessage()    {}
func (*Comparison) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{12}
}

func (m *Comparison) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Comparison.Unmarshal(m, b)
}
func (m *Comparison) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Comparison.Marshal(b, m, deterministic)
}
func (m *Comparison) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Comparison.Merge(m, src)
}
func (m *Comparison) XXX_Size() int {
	return xxx_messageInfo_Comparison.Size(m)
}
func (m *Comparison) XXX_DiscardUnknown() {
	xxx_messageInfo_Comparison.DiscardUnknown(m)
}

var xxx_messageInfo_Comparison proto.InternalMessageInfo

func (m *Comparison) GetGenus() string {
	if m != nil {
		return m.Genus
	}
	return ""
}

func (m *Comparison) GetSpecies() string {
	if m != nil {
		return m.Species
	}
	return ""
}

func (m *Comparison) GetSpeciesAuthorship() *Authorship {
	if m != nil {
		return m.SpeciesAuthorship
	}
	return nil
}

func (m *Comparison) GetComparison() string {
	if m != nil {
		return m.Comparison
	}
	return ""
}

type Approximation struct {
	// genus of the name.
	Genus string `protobuf:"bytes,1,opt,name=genus,proto3" json:"genus,omitempty"`
	// specific epithet if given (in case if the approximation for subspecies
	// for example).
	Species string `protobuf:"bytes,2,opt,name=species,proto3" json:"species,omitempty"`
	// species_authorship, if given.
	SpeciesAuthorship *Authorship `protobuf:"bytes,3,opt,name=species_authorship,json=speciesAuthorship,proto3" json:"species_authorship,omitempty"`
	// approximation marker, like sp.
	Approximation string `protobuf:"bytes,4,opt,name=approximation,proto3" json:"approximation,omitempty"`
	// unparsed annotation of the name.
	Ignored              string   `protobuf:"bytes,5,opt,name=ignored,proto3" json:"ignored,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Approximation) Reset()         { *m = Approximation{} }
func (m *Approximation) String() string { return proto.CompactTextString(m) }
func (*Approximation) ProtoMessage()    {}
func (*Approximation) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{13}
}

func (m *Approximation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Approximation.Unmarshal(m, b)
}
func (m *Approximation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Approximation.Marshal(b, m, deterministic)
}
func (m *Approximation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Approximation.Merge(m, src)
}
func (m *Approximation) XXX_Size() int {
	return xxx_messageInfo_Approximation.Size(m)
}
func (m *Approximation) XXX_DiscardUnknown() {
	xxx_messageInfo_Approximation.DiscardUnknown(m)
}

var xxx_messageInfo_Approximation proto.InternalMessageInfo

func (m *Approximation) GetGenus() string {
	if m != nil {
		return m.Genus
	}
	return ""
}

func (m *Approximation) GetSpecies() string {
	if m != nil {
		return m.Species
	}
	return ""
}

func (m *Approximation) GetSpeciesAuthorship() *Authorship {
	if m != nil {
		return m.SpeciesAuthorship
	}
	return nil
}

func (m *Approximation) GetApproximation() string {
	if m != nil {
		return m.Approximation
	}
	return ""
}

func (m *Approximation) GetIgnored() string {
	if m != nil {
		return m.Ignored
	}
	return ""
}

type Authorship struct {
	// value is authorship string.
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	// list of all authors in the name (might include 'ex' and 'emend' authors).
	AllAuthors []string `protobuf:"bytes,2,rep,name=all_authors,json=allAuthors,proto3" json:"all_authors,omitempty"`
	// authors of the original combination.
	Original *AuthGroup `protobuf:"bytes,3,opt,name=original,proto3" json:"original,omitempty"`
	// authors of a new combination.
	Combination          *AuthGroup `protobuf:"bytes,4,opt,name=combination,proto3" json:"combination,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Authorship) Reset()         { *m = Authorship{} }
func (m *Authorship) String() string { return proto.CompactTextString(m) }
func (*Authorship) ProtoMessage()    {}
func (*Authorship) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{14}
}

func (m *Authorship) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Authorship.Unmarshal(m, b)
}
func (m *Authorship) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Authorship.Marshal(b, m, deterministic)
}
func (m *Authorship) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authorship.Merge(m, src)
}
func (m *Authorship) XXX_Size() int {
	return xxx_messageInfo_Authorship.Size(m)
}
func (m *Authorship) XXX_DiscardUnknown() {
	xxx_messageInfo_Authorship.DiscardUnknown(m)
}

var xxx_messageInfo_Authorship proto.InternalMessageInfo

func (m *Authorship) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Authorship) GetAllAuthors() []string {
	if m != nil {
		return m.AllAuthors
	}
	return nil
}

func (m *Authorship) GetOriginal() *AuthGroup {
	if m != nil {
		return m.Original
	}
	return nil
}

func (m *Authorship) GetCombination() *AuthGroup {
	if m != nil {
		return m.Combination
	}
	return nil
}

type AuthGroup struct {
	// list of authors in the group.
	Authors []string `protobuf:"bytes,1,rep,name=authors,proto3" json:"authors,omitempty"`
	// year of the publication.
	Year string `protobuf:"bytes,2,opt,name=year,proto3" json:"year,omitempty"`
	// approximate_year is true, if the year is uncertain.
	ApproximateYear bool `protobuf:"varint,3,opt,name=approximate_year,json=approximateYear,proto3" json:"approximate_year,omitempty"`
	// ex_authors are authors of a publication where name was described.
	ExAuthors *Authors `protobuf:"bytes,4,opt,name=ex_authors,json=exAuthors,proto3" json:"ex_authors,omitempty"`
	// emend_authors are authors that altered name meaning.
	EmendAuthors         *Authors `protobuf:"bytes,5,opt,name=emend_authors,json=emendAuthors,proto3" json:"emend_authors,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthGroup) Reset()         { *m = AuthGroup{} }
func (m *AuthGroup) String() string { return proto.CompactTextString(m) }
func (*AuthGroup) ProtoMessage()    {}
func (*AuthGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{15}
}

func (m *AuthGroup) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthGroup.Unmarshal(m, b)
}
func (m *AuthGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthGroup.Marshal(b, m, deterministic)
}
func (m *AuthGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthGroup.Merge(m, src)
}
func (m *AuthGroup) XXX_Size() int {
	return xxx_messageInfo_AuthGroup.Size(m)
}
func (m *AuthGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthGroup.DiscardUnknown(m)
}

var xxx_messageInfo_AuthGroup proto.InternalMessageInfo

func (m *AuthGroup) GetAuthors() []string {
	if m != nil {
		return m.Authors
	}
	return nil
}

func (m *AuthGroup) GetYear() string {
	if m != nil {
		return m.Year
	}
	return ""
}

func (m *AuthGroup) GetApproximateYear() bool {
	if m != nil {
		return m.ApproximateYear
	}
	return false
}

func (m *AuthGroup) GetExAuthors() *Authors {
	if m != nil {
		return m.ExAuthors
	}
	return nil
}

func (m *AuthGroup) GetEmendAuthors() *Authors {
	if m != nil {
		return m.EmendAuthors
	}
	return nil
}

type Authors struct {
	// authors is a list of authors.
	Authors []string `protobuf:"bytes,1,rep,name=authors,proto3" json:"authors,omitempty"`
	// year of the publication.
	Year string `protobuf:"bytes,2,opt,name=year,proto3" json:"year,omitempty"`
	// approximate_year is true if exact year of the publication is uncertain.
	ApproximateYear      bool     `protobuf:"varint,3,opt,name=approximate_year,json=approximateYear,proto3" json:"approximate_year,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Authors) Reset()         { *m = Authors{} }
func (m *Authors) String() string { return proto.CompactTextString(m) }
func (*Authors) ProtoMessage()    {}
func (*Authors) Descriptor() ([]byte, []int) {
	return fileDescriptor_586948aee85e7dfc, []int{16}
}

func (m *Authors) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Authors.Unmarshal(m, b)
}
func (m *Authors) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Authors.Marshal(b, m, deterministic)
}
func (m *Authors) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authors.Merge(m, src)
}
func (m *Authors) XXX_Size() int {
	return xxx_messageInfo_Authors.Size(m)
}
func (m *Authors) XXX_DiscardUnknown() {
	xxx_messageInfo_Authors.DiscardUnknown(m)
}

var xxx_messageInfo_Authors proto.InternalMessageInfo

func (m *Authors) GetAuthors() []string {
	if m != nil {
		return m.Authors
	}
	return nil
}

func (m *Authors) GetYear() string {
	if m != nil {
		return m.Year
	}
	return ""
}

func (m *Authors) GetApproximateYear() bool {
	if m != nil {
		return m.ApproximateYear
	}
	return false
}

func init() {
	proto.RegisterEnum("pb.NameType", NameType_name, NameType_value)
	proto.RegisterType((*Version)(nil), "pb.Version")
	proto.RegisterType((*Void)(nil), "pb.Void")
	proto.RegisterType((*InputArray)(nil), "pb.InputArray")
	proto.RegisterType((*OutputArray)(nil), "pb.OutputArray")
	proto.RegisterType((*Parsed)(nil), "pb.Parsed")
	proto.RegisterType((*HybridFormula)(nil), "pb.HybridFormula")
	proto.RegisterType((*Canonical)(nil), "pb.Canonical")
	proto.RegisterType((*Position)(nil), "pb.Position")
	proto.RegisterType((*QualityWarning)(nil), "pb.QualityWarning")
	proto.RegisterType((*Uninomial)(nil), "pb.Uninomial")
	proto.RegisterType((*Species)(nil), "pb.Species")
	proto.RegisterType((*InfraSpecies)(nil), "pb.InfraSpecies")
	proto.RegisterType((*Comparison)(nil), "pb.Comparison")
	proto.RegisterType((*Approximation)(nil), "pb.Approximation")
	proto.RegisterType((*Authorship)(nil), "pb.Authorship")
	proto.RegisterType((*AuthGroup)(nil), "pb.AuthGroup")
	proto.RegisterType((*Authors)(nil), "pb.Authors")
}

func init() { proto.RegisterFile("gnparser.proto", fileDescriptor_586948aee85e7dfc) }

var fileDescriptor_586948aee85e7dfc = []byte{
	// 1213 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xdd, 0x6e, 0xdc, 0x44,
	0x14, 0x5e, 0xef, 0xaf, 0x7d, 0xf6, 0x27, 0xee, 0x10, 0x55, 0xa3, 0x22, 0xda, 0xc8, 0x80, 0x48,
	0x8b, 0x48, 0x4b, 0x11, 0x17, 0x08, 0x81, 0xb4, 0x4d, 0xd3, 0x64, 0x45, 0xb3, 0x1b, 0x26, 0x4d,
	0xa0, 0xe2, 0xc2, 0x1a, 0xef, 0x4e, 0x93, 0xa1, 0xf6, 0xd8, 0x1d, 0xdb, 0xa5, 0x8b, 0xc4, 0x6b,
	0x70, 0xc3, 0x05, 0xe2, 0x45, 0xb8, 0xe0, 0x9a, 0x77, 0xe0, 0x55, 0xd0, 0x8c, 0xc7, 0x5e, 0x6f,
	0x69, 0x95, 0x06, 0x09, 0xee, 0xce, 0xf9, 0xbe, 0xe3, 0x99, 0x73, 0xbe, 0x39, 0x73, 0x3c, 0x30,
	0x3a, 0x13, 0x09, 0x95, 0x29, 0x93, 0x3b, 0x89, 0x8c, 0xb3, 0x18, 0x35, 0x93, 0xc0, 0xfb, 0x12,
	0x7a, 0xa7, 0x4c, 0xa6, 0x3c, 0x16, 0x68, 0x13, 0x3a, 0xcf, 0x69, 0x98, 0x33, 0x6c, 0x6d, 0x59,
	0xdb, 0x0e, 0x29, 0x1c, 0xf4, 0x0e, 0x40, 0x90, 0xf3, 0x70, 0xe1, 0x67, 0x3c, 0x62, 0xb8, 0xa9,
	0x29, 0x47, 0x23, 0x8f, 0x78, 0xc4, 0xbc, 0x2e, 0xb4, 0x4f, 0x63, 0xbe, 0xf0, 0xce, 0x01, 0x26,
	0x22, 0xc9, 0xb3, 0xb1, 0x94, 0x74, 0x89, 0x6e, 0x40, 0xff, 0xfb, 0x38, 0x48, 0x7d, 0x91, 0x47,
	0x01, 0x93, 0x7a, 0xc1, 0x0e, 0x01, 0x05, 0x4d, 0x35, 0x82, 0xde, 0x85, 0x61, 0xfa, 0x94, 0x27,
	0xfe, 0x3c, 0x64, 0x54, 0x70, 0x71, 0xa6, 0x17, 0xb6, 0xc9, 0x40, 0x81, 0xbb, 0x06, 0x53, 0x09,
	0x09, 0x1a, 0xb1, 0x14, 0xb7, 0xb6, 0x5a, 0x2a, 0x21, 0xed, 0x78, 0x1f, 0x43, 0x7f, 0x96, 0x67,
	0xd5, 0x56, 0x1e, 0x74, 0x63, 0xed, 0x62, 0x6b, 0xab, 0xb5, 0xdd, 0xbf, 0x0b, 0x3b, 0x49, 0xb0,
	0x73, 0xa4, 0xca, 0x5c, 0x10, 0xc3, 0x78, 0xbf, 0x75, 0xa1, 0x5b, 0x40, 0xe8, 0x2a, 0x74, 0xb5,
	0x06, 0x0b, 0x9d, 0x94, 0x4d, 0x8c, 0x87, 0x30, 0xf4, 0x9e, 0xe5, 0x34, 0xe4, 0xd9, 0x52, 0xa7,
	0xd2, 0x21, 0xa5, 0x8b, 0x3e, 0x87, 0x0d, 0x63, 0xfa, 0x3f, 0x50, 0xa9, 0x93, 0x6d, 0xe9, 0x9d,
	0x90, 0xda, 0xe9, 0xeb, 0x82, 0xfa, 0xa6, 0x60, 0xc8, 0xe8, 0xd9, 0x9a, 0x8f, 0xae, 0x81, 0xfd,
	0x9c, 0xc9, 0x80, 0x66, 0x3c, 0xc2, 0x6d, 0xad, 0x5d, 0xe5, 0xa3, 0xeb, 0x00, 0x22, 0x96, 0x11,
	0x0d, 0xf9, 0x8f, 0x6c, 0x81, 0x3b, 0x9a, 0xad, 0x21, 0xe8, 0x43, 0x70, 0xe6, 0x54, 0xc4, 0x82,
	0xcf, 0x69, 0x88, 0xbb, 0x5b, 0xd6, 0x76, 0xff, 0xee, 0x50, 0x6d, 0xb9, 0x5b, 0x82, 0x64, 0xc5,
	0xa3, 0x1d, 0x00, 0x9a, 0x67, 0xe7, 0xb1, 0x4c, 0xcf, 0x79, 0x82, 0x7b, 0x3a, 0x7a, 0xa4, 0xa2,
	0xc7, 0x15, 0x4a, 0x6a, 0x11, 0xe8, 0x16, 0x38, 0x49, 0x9c, 0xf2, 0x8c, 0xc7, 0x22, 0xc5, 0xb6,
	0xae, 0x67, 0xa0, 0x95, 0x33, 0x20, 0x59, 0xd1, 0x4a, 0xb3, 0xf3, 0x65, 0x20, 0xf9, 0x02, 0x3b,
	0x85, 0x66, 0x85, 0xa7, 0x8a, 0x0b, 0xe8, 0x3c, 0x63, 0x92, 0x53, 0x0c, 0x9a, 0xa9, 0x7c, 0x84,
	0xa0, 0x9d, 0x51, 0x1e, 0xe2, 0xbe, 0x2e, 0x4b, 0xdb, 0x68, 0x04, 0x4d, 0xbe, 0xc0, 0x03, 0x8d,
	0x34, 0xf9, 0x02, 0xbd, 0x0f, 0xa3, 0xa2, 0x1f, 0xfd, 0xe7, 0x45, 0x0b, 0xe2, 0xa1, 0xe6, 0x86,
	0x05, 0x5a, 0xf6, 0xe5, 0x16, 0xf4, 0xe7, 0x54, 0x2e, 0xb8, 0x28, 0x8e, 0x67, 0xa4, 0x8f, 0xa7,
	0x0e, 0xa1, 0x9b, 0xe0, 0xa8, 0xde, 0xf0, 0xb3, 0x65, 0xc2, 0xf0, 0xc6, 0x96, 0xb5, 0x3d, 0x2a,
	0x8a, 0x99, 0xd2, 0x88, 0x3d, 0x5a, 0x26, 0x8c, 0xd8, 0xc2, 0x58, 0xe8, 0x23, 0x70, 0x72, 0xc1,
	0x45, 0x1c, 0x71, 0x1a, 0x62, 0x77, 0x25, 0xea, 0x49, 0x09, 0x1e, 0x34, 0xc8, 0x2a, 0x02, 0x7d,
	0x00, 0xbd, 0x34, 0x61, 0x73, 0xce, 0x52, 0x7c, 0x45, 0x07, 0xf7, 0x55, 0xf0, 0x71, 0x01, 0x1d,
	0x34, 0x48, 0xc9, 0xa2, 0x3b, 0x00, 0xf3, 0x38, 0x4a, 0xa8, 0xe4, 0x69, 0x2c, 0x30, 0x5a, 0xe9,
	0xbf, 0x5b, 0xa1, 0x07, 0x0d, 0x52, 0x8b, 0x41, 0x9f, 0xc1, 0x90, 0x26, 0x89, 0x8c, 0x5f, 0xf0,
	0x88, 0x2a, 0x9d, 0xf1, 0x5b, 0xfa, 0xa3, 0x2b, 0xfa, 0xd0, 0xea, 0xc4, 0x41, 0x83, 0xac, 0x47,
	0xa2, 0x7d, 0xb8, 0xba, 0x60, 0x4a, 0xd2, 0xd4, 0x2f, 0x8e, 0xc2, 0x7f, 0x12, 0xcb, 0x28, 0x0f,
	0x29, 0xde, 0xd4, 0x27, 0xa9, 0xd7, 0x38, 0xd0, 0xcc, 0x83, 0x82, 0x20, 0x9b, 0xe6, 0x83, 0x35,
	0xf4, 0x9e, 0x03, 0x3d, 0x83, 0x7b, 0x7f, 0x59, 0x30, 0x5c, 0x23, 0xd7, 0xa5, 0xb2, 0x2e, 0x23,
	0x55, 0xf3, 0x12, 0x52, 0xb5, 0xfe, 0x8d, 0x54, 0xed, 0x37, 0x95, 0x4a, 0x55, 0xc8, 0x42, 0x16,
	0x31, 0x91, 0x79, 0x5f, 0x81, 0x53, 0x5d, 0x1d, 0xd5, 0x9f, 0x69, 0xc6, 0x22, 0x33, 0xeb, 0xb4,
	0xad, 0xfa, 0x3c, 0xe5, 0x51, 0x12, 0x96, 0x63, 0xce, 0x78, 0x2a, 0xf6, 0x49, 0x1e, 0x86, 0x3a,
	0x55, 0x87, 0x68, 0xdb, 0x7b, 0x00, 0x76, 0x79, 0x55, 0x74, 0xaf, 0xab, 0xce, 0x33, 0x6b, 0x29,
	0x5b, 0xcd, 0xae, 0x34, 0xa3, 0x32, 0x33, 0xd3, 0xa4, 0x70, 0x90, 0x0b, 0x2d, 0x26, 0x16, 0x7a,
	0xa1, 0x0e, 0x51, 0xa6, 0x77, 0x1f, 0x46, 0xeb, 0x23, 0xa4, 0x3e, 0x89, 0xac, 0xf5, 0x49, 0x84,
	0xa1, 0x17, 0xb1, 0x34, 0xa5, 0x67, 0x65, 0x82, 0xa5, 0xeb, 0xfd, 0x04, 0x4e, 0x75, 0x2a, 0xaf,
	0x99, 0xe3, 0x08, 0xda, 0x92, 0x8a, 0xa7, 0xe6, 0x4b, 0x6d, 0x9b, 0x61, 0xc8, 0x44, 0x66, 0x4a,
	0x33, 0xde, 0x4b, 0xc3, 0xa4, 0x7d, 0xd1, 0x30, 0xf1, 0xfe, 0xb4, 0xa0, 0x67, 0x0e, 0x5a, 0xed,
	0x7e, 0xc6, 0x44, 0x9e, 0x96, 0xbb, 0x6b, 0x07, 0xbd, 0x0d, 0x4e, 0x9a, 0x07, 0x7e, 0xc1, 0x14,
	0x29, 0xd8, 0x69, 0x1e, 0xec, 0x6b, 0x12, 0xaf, 0x3a, 0xa7, 0xc8, 0xa3, 0x6a, 0x95, 0x2f, 0x00,
	0x19, 0xd3, 0xbf, 0x30, 0xa1, 0x2b, 0x26, 0x72, 0x05, 0xa1, 0x4f, 0x61, 0xc8, 0xc5, 0x13, 0x49,
	0xfd, 0x72, 0xf9, 0x8e, 0xbe, 0x1e, 0xae, 0xfa, 0x72, 0xa2, 0x08, 0x93, 0x34, 0x19, 0xf0, 0x9a,
	0xe7, 0x9d, 0xc3, 0xa0, 0xce, 0x5e, 0x42, 0xd0, 0x75, 0xe1, 0x5a, 0x17, 0x0a, 0xf7, 0x8b, 0x05,
	0xb0, 0xea, 0xfa, 0xd7, 0x68, 0x87, 0xd7, 0x2f, 0xd6, 0x85, 0xf2, 0xb4, 0xde, 0x54, 0x9e, 0xeb,
	0x6b, 0x17, 0xb1, 0xf8, 0x3d, 0xd5, 0x10, 0xef, 0x77, 0x0b, 0x86, 0x6b, 0xd7, 0xeb, 0xff, 0x4e,
	0xf0, 0xbd, 0x57, 0xdd, 0x7b, 0xe7, 0xe5, 0x69, 0x88, 0xa1, 0xc7, 0xcf, 0x44, 0x2c, 0xab, 0x9f,
	0x68, 0xe9, 0x7a, 0xbf, 0x5a, 0x00, 0xb5, 0xe5, 0x5e, 0x7d, 0x8e, 0x37, 0xa0, 0x4f, 0xc3, 0xb0,
	0xcc, 0x0f, 0x37, 0xf5, 0x5b, 0x03, 0x68, 0x18, 0x9a, 0x2f, 0xd1, 0x4d, 0xb0, 0x63, 0xc9, 0xcf,
	0xd4, 0xcf, 0xc6, 0xa4, 0x3e, 0x2c, 0x53, 0xdf, 0x97, 0x71, 0x9e, 0x90, 0x8a, 0x46, 0xb7, 0xa1,
	0x3f, 0x8f, 0xa3, 0x80, 0x8b, 0xfa, 0x98, 0x7a, 0x29, 0xba, 0x1e, 0xe1, 0xfd, 0x61, 0x81, 0x53,
	0x51, 0xaa, 0x92, 0x32, 0x0d, 0x4b, 0xa7, 0x51, 0xba, 0xaa, 0xd9, 0x96, 0x8c, 0xca, 0xb2, 0xd9,
	0x94, 0x8d, 0x6e, 0x82, 0xbb, 0x12, 0x82, 0xf9, 0x9a, 0x6f, 0xe9, 0xdf, 0xf0, 0x46, 0x0d, 0x7f,
	0xac, 0x42, 0x6f, 0x01, 0xb0, 0x17, 0x55, 0x89, 0xed, 0xd5, 0x78, 0x36, 0x35, 0x12, 0x87, 0xbd,
	0x28, 0xcb, 0xbd, 0x03, 0x43, 0x35, 0x2f, 0x17, 0x55, 0x78, 0xe7, 0x9f, 0xe1, 0x03, 0x1d, 0x61,
	0x3c, 0x2f, 0x80, 0x5e, 0xf9, 0xf1, 0x7f, 0x55, 0xc1, 0xad, 0x9f, 0x2d, 0xb0, 0xcb, 0xdf, 0x39,
	0xb2, 0xa1, 0x3d, 0x9d, 0x4d, 0xf7, 0xdc, 0x06, 0x1a, 0x82, 0x73, 0x32, 0x9d, 0x4c, 0x67, 0x87,
	0x93, 0xf1, 0x43, 0xd7, 0x42, 0x7d, 0xe8, 0x1d, 0x1f, 0xed, 0xed, 0x4e, 0xf6, 0x8e, 0xdd, 0x26,
	0x1a, 0x01, 0xec, 0xce, 0x0e, 0x8f, 0xc6, 0x64, 0x72, 0x3c, 0x9b, 0xba, 0x2d, 0xb4, 0x09, 0xee,
	0xf8, 0xe8, 0x88, 0xcc, 0xbe, 0xf5, 0x8f, 0x4f, 0x08, 0x99, 0xed, 0x8f, 0x1f, 0xed, 0xb9, 0x6d,
	0xb5, 0xc2, 0xca, 0xed, 0x20, 0x17, 0x06, 0xd3, 0xf1, 0xe1, 0xde, 0x7d, 0xff, 0xe0, 0xf1, 0x3d,
	0x32, 0xb9, 0xef, 0x76, 0x11, 0x82, 0x51, 0x61, 0xfb, 0x0f, 0x66, 0xe4, 0xf0, 0xe4, 0xe1, 0xd8,
	0xed, 0x21, 0x07, 0x3a, 0xa7, 0x13, 0x72, 0x72, 0xec, 0xda, 0x77, 0xbf, 0x03, 0x7b, 0x7f, 0x5a,
	0x3c, 0x58, 0xd0, 0x75, 0x68, 0x9d, 0x32, 0x89, 0x6c, 0x25, 0x95, 0x7a, 0x15, 0x5f, 0xd3, 0xa2,
	0x99, 0x77, 0x8c, 0xd7, 0x40, 0xb7, 0x01, 0xf4, 0x33, 0xb4, 0x78, 0xb9, 0x8e, 0x8a, 0x31, 0x54,
	0xbe, 0x64, 0xaf, 0x6d, 0x28, 0xbf, 0xf6, 0xb4, 0xf5, 0x1a, 0x41, 0x57, 0x3f, 0xd4, 0x3f, 0xf9,
	0x3b, 0x00, 0x00, 0xff, 0xff, 0xd4, 0x3b, 0x74, 0x22, 0xba, 0x0b, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GNparserClient is the client API for GNparser service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GNparserClient interface {
	// Ver takes an empty argument (Void) and returns description of the gnparser
	// version and build date and time.
	Ver(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error)
	// ParseArray takes a list of name-strings (up to 10000), and retuns back
	// a list of parsed results, preserving the order of input.
	ParseArray(ctx context.Context, in *InputArray, opts ...grpc.CallOption) (*OutputArray, error)
}

type gNparserClient struct {
	cc *grpc.ClientConn
}

func NewGNparserClient(cc *grpc.ClientConn) GNparserClient {
	return &gNparserClient{cc}
}

func (c *gNparserClient) Ver(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/pb.GNparser/Ver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gNparserClient) ParseArray(ctx context.Context, in *InputArray, opts ...grpc.CallOption) (*OutputArray, error) {
	out := new(OutputArray)
	err := c.cc.Invoke(ctx, "/pb.GNparser/ParseArray", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GNparserServer is the server API for GNparser service.
type GNparserServer interface {
	// Ver takes an empty argument (Void) and returns description of the gnparser
	// version and build date and time.
	Ver(context.Context, *Void) (*Version, error)
	// ParseArray takes a list of name-strings (up to 10000), and retuns back
	// a list of parsed results, preserving the order of input.
	ParseArray(context.Context, *InputArray) (*OutputArray, error)
}

func RegisterGNparserServer(s *grpc.Server, srv GNparserServer) {
	s.RegisterService(&_GNparser_serviceDesc, srv)
}

func _GNparser_Ver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GNparserServer).Ver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GNparser/Ver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GNparserServer).Ver(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _GNparser_ParseArray_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputArray)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GNparserServer).ParseArray(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.GNparser/ParseArray",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GNparserServer).ParseArray(ctx, req.(*InputArray))
	}
	return interceptor(ctx, in, info, handler)
}

var _GNparser_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.GNparser",
	HandlerType: (*GNparserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ver",
			Handler:    _GNparser_Ver_Handler,
		},
		{
			MethodName: "ParseArray",
			Handler:    _GNparser_ParseArray_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gnparser.proto",
}
