package output

import (
	"bytes"

	jsoniter "github.com/json-iterator/go"
	grm "gitlab.com/gogna/gnparser/grammar"
	"gitlab.com/gogna/gnparser/stemmer"
)

// Output is a result of parsing that can be returned in JSON or CSV  formats.
type Output struct {
	// Parsed is true if parsing of a name-string succeeded.
	Parsed bool `json:"parsed"`
	// Quality of parsing. 1 - no problems, 2 - some small problems,
	// 3 - significant problems with a name-string.
	Quality int `json:"quality"`
	// Warnings generated by parsing. A warning contains a message and
	// an associated with it quality of parsing. The largest quality number
	// becomes an overal quality of parsing.
	Warnings []Warning `json:"qualityWarnings,omitempty"`
	// Verbatim input of a name-string.
	Verbatim string `json:"verbatim"`
	// Normalized is a cleaned-up version of a name.
	Normalized string `json:"normalized,omitempty"`
	// Cardinality is a number of main elements in a name. 0 - N/A, 1 - Uninomial,
	// 2 - Binomial, 3 - Trinomial etc.
	Cardinality int `json:"cardinality"`
	// CanonicalName -- three versions of a canonical form of a name.
	CanonicalName *canonical `json:"canonicalName,omitempty"`
	// Authorship of a name-string, if available.
	Authorship string `json:"authorship,omitempty"`
	// Parsing details.
	Details []interface{} `json:"details,omitempty"`
	// Positions and a semantic meanings of words in the name-strings.
	Positions []pos `json:"positions,omitempty"`
	// Unofficial name-string label (for example names from BOLD project,
	// names with annotations etc.).
	Surrogate bool `json:"surrogate"`
	// Name seem to be a virus, vector, prion etc.
	Virus bool `json:"virus"`
	// Hybrid is true if a name-string is classied as a hybrid.
	Hybrid bool `json:"hybrid"`
	// Bacteria is true if a name-string is classified as a bacteria.
	Bacteria bool `json:"bacteria"`
	// Tail is an unparseable tail of a name-string.
	Tail string `json:"unparsedTail,omitempty"`
	// NameStringID is a UUID v5 of a verbatim version of a name-string. This
	// UUID uses globalnames.org DNS as a seed.
	NameStringID string `json:"nameStringId"`
	// ParserVersion is a version of the gnparser used to generate the output.
	ParserVersion string `json:"parserVersion"`
}

func NewOutput(sn *grm.ScientificNameNode) *Output {
	var co *canonical
	var quality int
	var au string
	var ws []Warning
	var ps []pos
	var hybrid bool
	var parsed bool
	det := sn.Details()
	c := sn.Canonical()
	if c != nil {
		co = &canonical{
			Full:   c.ValueRanked,
			Simple: c.Value,
			Stem:   stemmer.StemCanonical(c.Value),
		}
		ws, quality = qualityAndWarnings(sn.Warnings)
		ps = convertPos(sn.Pos())
		hybrid = sn.Hybrid
		parsed = true
		lastAuthorship := sn.LastAuthorship()
		if lastAuthorship != nil {
			au = lastAuthorship.Value
		}

	}

	o := Output{
		Parsed:        parsed,
		Quality:       quality,
		Warnings:      ws,
		Verbatim:      sn.Verbatim,
		NameStringID:  sn.VerbatimID,
		Surrogate:     sn.Surrogate,
		CanonicalName: co,
		Virus:         sn.Virus,
		Hybrid:        hybrid,
		Normalized:    sn.Value(),
		Cardinality:   sn.Cardinality,
		Positions:     ps,
		Bacteria:      sn.Bacteria,
		Tail:          sn.Tail,
		Details:       det,
		Authorship:    au,
		ParserVersion: sn.ParserVersion,
	}
	return &o
}

func qualityAndWarnings(ws []grm.Warning) ([]Warning, int) {
	warns := prepareWarnings(ws)
	quality := 1
	if len(warns) > 0 {
		quality = warns[0].Quality
	}
	return warns, quality
}

// ToJSON converts Output to JSON representation.
func (o *Output) ToJSON(pretty bool) ([]byte, error) {
	if pretty {
		return jsoniter.MarshalIndent(o, "", "  ")
	}
	return jsoniter.Marshal(o)
}

// FromJSON converts JSON representation of Outout to Output object.
func FromJSON(data []byte) (Output, error) {
	var o Output
	r := bytes.NewReader(data)
	err := jsoniter.NewDecoder(r).Decode(&o)
	return o, err
}

type canonical struct {
	Full   string `json:"full"`
	Simple string `json:"simple"`
	Stem   string `json:"stem"`
}

type pos struct {
	Type  string
	Start int
	End   int
}

func convertPos(pp []grm.Pos) []pos {
	res := make([]pos, len(pp))
	for i, v := range pp {
		t, ok := wordTypeMap[v.Type]
		if !ok {
			t = "??????"
		}
		res[i] = pos{Type: t, Start: v.Start, End: v.End}
	}
	return res
}

func (p *pos) MarshalJSON() ([]byte, error) {
	arr := []interface{}{p.Type, p.Start, p.End}
	return jsoniter.Marshal(arr)
}

func (p *pos) UnmarshalJSON(bs []byte) error {
	arr := []interface{}{}
	err := jsoniter.Unmarshal(bs, &arr)
	if err != nil {
		return err
	}
	p.Type = arr[0].(string)
	p.Start = int(arr[1].(float64))
	p.End = int(arr[2].(float64))
	return nil
}
